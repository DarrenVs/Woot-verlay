<!DOCTYPE html>
<html lang="en">
  <!-- HEAD -->
  <head>
    <!-- page information -->
		<meta charset="UTF-8">
		<title>DJ's Analog Overlay</title>
		<meta name="description" content="Displays pressure sensitive stats">
		<meta name="viewport" content="width=device-width">
		<!-- css stylesheets -->
		<link rel='stylesheet' type='text/css' href="styles.css">
  </head>

  <!-- BODY -->
  <body style="font-family: monospace;">
    <!-- keyboard and keys display -->
    <section id="keyboard"></section>

    <!-- HUD -->
    <section id="keyPool">
      <h2>&ensp;>> Add a key</h1>
    </section>
    <!-- optional information -->
    <div class = "optionalInfo">
      <h1 id="values">Start pressing!</h1>
      <hr>
      <h2 id="output"></h2>
    </div>

  </body>


  <!-- SCRIPTING -->
  <script>
    // disable (most) user keyboard inputs
    document.onkeydown = function(e) {return false;}

    // values
    const output = document.querySelector("#output");
    const values = document.querySelector("#values");
    var latestInputs = new Array(); // logs inputs of keys


    function resetKeys(){
        var childKeys = document.getElementById('keyboard').getElementsByClassName('key');
        for( i=0; i< childKeys.length; i++ ) childKeys[i].getElementsByClassName('progress')[0].style.height = "0";
      }


    // function to bind to server
    function connect() {
      // websocket
      const wsUri = "ws://127.0.0.1/";
      const websocket = new WebSocket(wsUri);

      websocket.onopen = (e) => { console.log("Connected to server."); };

      websocket.onclose = (e) => {
        console.log("Socket is closed. Reconnect will be attempted in 5 seconds.");
        resetKeys();
        // reset key input values
        setTimeout(function() {
          connect();
        }, 5000);
      };

     

      websocket.onmessage = (e) => { update(`${e.data}`); };

      websocket.onerror = (e) => { console.log("Error.  " + e.data); };
    }

    // function to update the display on the screen
    function update(message) {
      if(message == ""){
        resetKeys();
        return;
      }
      var content = "";
      // split message into keys
      const keys = message.split(/[()]/);
      keys.filter(element => element.length != 0).forEach(element => {
        // split keys into values
        var values = element.split(':');
        content += "(" + values[0] + ", " + values[1].substring(0, 4) + ", " + values[2] + ") ";
        // draw key with values
        var activeKey;
        if(activeKey = document.getElementById(values[0])){
          // draw height of key
          activeKey.style.height = parseFloat(values[1]*100)+"%";
          activeKey.style.width = parseFloat(values[1]*100)+"%";
          // activeKey.style.borderRadius =  (100-parseFloat(values[1]*100))+"px";
          // draw active state of key
          activeKey.style.backgroundColor = values[2]==1 ? "var(--active)" : null;
        }
      })

      // write active keys
      values.innerHTML = "Active keys: " + content;

      // append to key log and print
      latestInputs.unshift(content);
      if(latestInputs.length > 30) latestInputs.pop();
      var keyLog = "";
      latestInputs.forEach(element => keyLog += element + "<br>");
      output.innerHTML = keyLog;
    }

    // attempt connection
    connect();

  </script>


  <script >
    
    // key class
    class Key{
      constructor(keyCode, label, x, y, width, height){
        this.keyCode = keyCode;
        this.label = label;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
    }

    const keyPairs = {
      A:4, B:5, C:6, D:7, E:8, F:9, G:10, H:11, I:12, J:13, K:14, L:15, M:16, N:17, O:18, P:19, Q:20, R:21, S:22, T:23, U:24,V:25, W:26, X:27, Y:28, Z:29,
      1:30, 2:31, 3:32, 4:33, 5:34, 6:35, 7:36, 8:37, 9:38, 0:39,
      Enter:40, Esc:41, Back:42, Tab:43, __:44, '-':45, '+':46, '[':47, ']':48, '\\':49,
      '; :':51, '\' "':52, '~':53, ',':54, '.':55, '/ ?':56, Caps:57,
      F1:58, F2:59, F3:60, F4:61, F5:62, F6:63, F7:64, F8:65, F9:66, F10:67, F11:68, F12:69,
      PrtScr:70, ScrLk:71, "⏵⏸":72, Ins:73, Home:74, PgUp:75, Del:76, End:77, PgDn:78,
      '▶':79, '◀':80, '▼':81, '▲':82, NumLk:83, Menu:101,
      Ctrl:224, "L🡅":225, Alt:226, Win:227, RCtrl:228, "R🡅":229, RMenu:230, RWin:231, Fn:1033,
    };

    function buildOptions(){
      // clear existing options
      var keyPool = document.getElementById("keyPool");
      while (keyPool.firstChild) {
        keyPool.removeChild(keyPool.firstChild);
      }
      // add all options
      for (const [label, keyID] of Object.entries(keyPairs)){
          if(!activeKeyIDs.includes(keyID)){
          var curDiv = document.createElement('span');
          curDiv.className = "keyOption";
          curDiv.textContent = label;
          keyPool.append(curDiv);
          // attach onclick listener
          curDiv.onclick = function(){
            buildKey( new Key(keyID, label, parseInt((Math.random()*4))*72 + 600, parseInt((Math.random()*4))*72 + 300, 1, 1));
            saveState();
          }
        }
      }
    }




    // Store list of keys and environment variables
    var keys = [];
    var activeKeyIDs = [];
    getState();

    var keySize = parseInt(getComputedStyle(document.body).getPropertyValue('--key-size'));
    var keyboard = document.getElementById("keyboard");

    // builds a key given an object
    function buildKey(curKey){
      var curDiv = document.createElement('div');
      activeKeyIDs.push(curKey.keyCode);
      keyboard.appendChild(curDiv);
      // key styling
      curDiv.id = "draggable"; 
      curDiv.className = "key";
      curDiv.style.top = curKey.y + "px";
      curDiv.style.left = curKey.x + "px";
      curDiv.style.width = curKey.width == 1 ? "var(--key-size)" : "calc(var(--key-size)*" + curKey.width + ")";
      curDiv.style.height = curKey.height == 1 ? "var(--key-size)" : "calc(var(--key-size)*" + curKey.height + ")";
      // progress styling
      var curProgress = document.createElement('div');
      curDiv.appendChild(curProgress);
      curProgress.className = "progress";

      updateKeySettings(curProgress, 3, 1, false);



      curProgress.id = curKey.keyCode;
      // label styling
      var curLabel = document.createElement('span');
      curDiv.appendChild(curLabel);
      curLabel.className = "label";
      curLabel.textContent = curKey.label;

      // make key draggable
      dragElement(curDiv);

      buildOptions();
    }

    // key obect
    // wh: 0=both, 1=heightonly, 2=widthonly
    // round: true or false rounding
    function updateKeySettings(keyObj, pos, wh, round){
      const positioning = { 
        0:"auto",  // mid
        1:"0 auto auto auto", // top
        2:"auto 0 auto auto", // right
        3:"auto auto 0 auto", // bottom
        4:"auto auto auto 0", // left
        5: "0 0 auto auto", // top right
        6: "auto 0 0 auto", // bottom right
        7: "auto auto 0 0 ", // bottom left
        8: "0 auto auto 0" // top left
      }
      // fill start direction
      keyObj.style['inset'] = positioning[pos];
      // width and height
      keyObj.style.minWidth =  wh==1?"100%":"0";  // if width enabled, only top mid and bottom positioning
      keyObj.style.minHeight =  wh==2?"100%":"0"; // if height enabled. only left mid right positioning
      // border
      keyObj.style.borderRadius = "0px";
      keyObj.style.setProperty('border-top-left-radius', '0', "important"); 

    }

    // get locally stored key states for usage
    function getState(){
      // localStorage.removeItem("keys");
      if(localStorage.getItem("keys") != null){ // retrieve locally stored keys
        var storedKeys = JSON.parse(localStorage.getItem("keys", storedKeys));
        storedKeys.forEach(element => {
          keys.push(new Key(element[0], element[1], element[2], element[3], element[4], element[5]));
        });

      } else{ // default keys
        keys = [
          new Key(26, "W", 156, 0, 1, 1), // W
          new Key(4, "A", 96, 72, 1, 1), // A
          new Key(22, "S", 168, 72, 1, 1), // S
          new Key(7, "D", 240, 72, 1, 1), // D
          new Key(225, "🡅", 0, 0, 1.6, 1), // Left Shift
          new Key(224, "Ctrl", 0, 72, 1.2, 1), // Left Ctrl
          new Key(44, "__", 324, 72, 1.8, 1), // Space
        ];
      }
    }
    
    // saves the state of all keys in local storage
    function saveState(){
      // store key array, key elements, and key size information
      var storedKeys = [];
      activeKeyIDs = [];
      var childKeys = document.getElementById('keyboard').getElementsByClassName('key');
      
      // turn key elements into arrays for storage
      for( i=0; i< childKeys.length; i++ )
      {
        var id = childKeys[i].getElementsByClassName('progress')[0].id;
        var label = childKeys[i].getElementsByClassName('label')[0].textContent;
        let keyData = [
        parseInt(id), label, parseInt(childKeys[i].style.left), parseInt(childKeys[i].style.top),
          childKeys[i].clientWidth/keySize, childKeys[i].clientHeight/keySize
        ]
        storedKeys.push(keyData);
        activeKeyIDs.push(parseInt(id));
        
      }
      // store updated keys in local storage
      localStorage.setItem("keys", JSON.stringify(storedKeys));
      buildOptions();
    }

    // create keys on screen
    keyboard.addEventListener('contextmenu', event => event.preventDefault());
    for (var i = 0; i < keys.length; i++) buildKey(keys[i]);

    // all functions related to dragging and resizing a key             
    function dragElement(elmnt) {
        // current position
        var x = parseInt(elmnt.style.left); 
        var y = parseInt(elmnt.style.top);
        // curent size
        var width = elmnt.clientWidth;
        var height = elmnt.clientHeight;
        // previous mouse position
        var oldPosX = 0;
        var oldPosY = 0;

        elmnt.onmousedown = dragMouseDown;

      async function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        // get the mouse cursor position at startup
        oldPosX = e.clientX;
        oldPosY = e.clientY;
        document.onmouseup = closeDragElement;

        // call a function whenever the cursor moves
        if(e.button === 2){ // delete element on left click
          elmnt.style.opacity = 0;
          elmnt.style.backgroundColor = "#925555";
          await new Promise(resolve => setTimeout(resolve, 1000));
          keyboard.removeChild(elmnt);
          saveState();
        } else if((e.clientX > parseInt(elmnt.style.left) + elmnt.offsetWidth)){ // resize width when dragging right side
          document.onmousemove = elementResizeWidth;
        } else if(e.clientY > parseInt(elmnt.style.top) + elmnt.offsetHeight){ // resize height when dragging bottom
          document.onmousemove = elementResizeHeight;
        }else{ // move on drag
          document.onmousemove = elementDrag;
        }
        

      }

      function elementResizeWidth(e){
        e = e || window.event;
        e.preventDefault();

        // calculate the new cursor position to add to width
        width += (e.clientX - oldPosX);
        
        // set the element's new position:
        elmnt.style.width = snapGrid(width) + "px";
        // set old values
        oldPosX = e.clientX;
      }

      function elementResizeHeight(e){
        e = e || window.event;
        e.preventDefault();

        // calculate the new cursor position to add to height
        height += (e.clientY - oldPosY);
        
        // set the element's new position:
        elmnt.style.height = snapGrid(height) + "px";
        // set old values
        oldPosY = e.clientY;
      }

      function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        // calculate the new cursor position:
        x += (e.clientX - oldPosX);
        y += (e.clientY - oldPosY);
        // set the element's new position:
        elmnt.style.top = snapGrid(y) + "px";
        elmnt.style.left = snapGrid(x) + "px";
        // set old values
        oldPosX = e.clientX;
        oldPosY = e.clientY;

      }

      function closeDragElement() {
        // stop moving when mouse button is released:
        document.onmouseup = null;
        document.onmousemove = null;
        saveState();
      }

      function snapGrid(num) {
         return Math.ceil(num / 12) * 12;
      }
    }
  
    buildOptions();
  </script>

</html>
