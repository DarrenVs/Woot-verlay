<!DOCTYPE html>
<html lang="en">
  <!-- HEAD -->
  <head>
    <!-- page information -->
		<meta charset="UTF-8">
		<title>DJ's Analog Overlay</title>
		<meta name="description" content="Displays pressure sensitive stats">
		<meta name="viewport" content="width=device-width">
		<!-- css stylesheets -->
		<link rel='stylesheet' type='text/css' href="styles.css">
  </head>

  <!-- BODY -->
  <body style="font-family: monospace;">
    <!-- keyboard and keys display -->
    <section id="keyboard"></section>

    <!-- optional information -->
    <div class = "optionalInfo">
      <h1 id="values">Values</h1>
      <hr>
      <h2 id="output"></h2>
    </div>

  </body>

  <!-- SCRIPTING -->
  <script>
    // disable (most) user keyboard inputs
    document.onkeydown = function(e) {return false;}

    // values
    const output = document.querySelector("#output");
    const values = document.querySelector("#values");

    var latestInputs = new Array(); // logs inputs of keys

    // function to bind to server
    function connect() {
      // websocket
      const wsUri = "ws://127.0.0.1/";
      const websocket = new WebSocket(wsUri);

      websocket.onopen = (e) => { console.log("Connected to server."); };

      websocket.onclose = (e) => {
        console.log("Socket is closed. Reconnect will be attempted in 5 seconds.");
        // reset key input values
        var childKeys = document.getElementById('keyboard').getElementsByClassName('key');
        for( i=0; i< childKeys.length; i++ ) childKeys[i].getElementsByClassName('progress')[0].style.height = "0";
        setTimeout(function() {
          connect();
        }, 5000);
      };

      websocket.onmessage = (e) => { update(`${e.data}`); };

      websocket.onerror = (e) => { console.log("Error.  " + e.data); };
    }

    // function to update the display on the screen
    function update(message) {
      var content = "";
      // split message into keys
      const keys = message.split(/[()]/);
      keys.filter(element => element.length != 0).forEach(element => {
        // split keys into values
        var values = element.split(':');
        content += "(" + values[0] + ", " + values[1].substring(0, 4) + ", " + values[2] + ") ";
        // draw key with values
        var activeKey;
        if(activeKey = document.getElementById(values[0])){
          // draw height of key
          activeKey.style.height = parseFloat(values[1]*100)+"%";
          // draw active state of key
          activeKey.style.backgroundColor = values[2]==1 ? "var(--active)" : null;
        }
      })

      // write active keys
      values.innerHTML = "Active keys: " + content;

      // append to key log and print
      latestInputs.unshift(content);
      if(latestInputs.length > 30) latestInputs.pop();
      var keyLog = "";
      latestInputs.forEach(element => keyLog += element + "<br>");
      output.innerHTML = keyLog;
    }

    // attempt connection
    connect();

  </script>


  <script>
    class Key{
      constructor(keyCode, label, x, y, width, height, visible){
        this.keyCode = keyCode;
        this.label = label;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.visible = visible;
      }

    }
    
    // Store list of keys
    var keys = [];
    getState();

    // builds a key given an object
    function buildKey(curKey){
      var curDiv = document.createElement('div');
      keyboard.appendChild(curDiv);
      // key styling
      curDiv.id = "draggable"; 
      curDiv.className = "key";
      curDiv.style.top = curKey.y + "px";
      curDiv.style.left = curKey.x + "px";
      curDiv.style.width = curKey.width == 1 ? "var(--key-size)" : "calc(var(--key-size)*" + curKey.width + ")";
      curDiv.style.height = curKey.height == 1 ? "var(--key-size)" : "calc(var(--key-size)*" + curKey.height + ")";
      curDiv.style.display = curKey.visible == true ? "visible" : "none";
      
      var curProgress = document.createElement('div');
      curDiv.appendChild(curProgress);
      // progress styling
      curProgress.className = "progress";
      curProgress.id = curKey.keyCode;

      var curLabel = document.createElement('span');
      curDiv.appendChild(curLabel);
      curLabel.className = "label";
      curLabel.textContent = curKey.label;
    }

    function getState(){
      // localStorage.removeItem("keys");
      if(localStorage.getItem("keys") != null){
        var storedKeys = JSON.parse(localStorage.getItem("keys", storedKeys));
        storedKeys.forEach(element => keys.push(new Key(element[0], element[1], element[2], element[3], element[4], element[5], element[6])));

      }
      else{ // default keys
        keys = [
          new Key(26, "W", 156, 0, 1, 1, true), // W
          new Key(4, "A", 96, 72, 1, 1, true), // A
          new Key(22, "S", 168, 72, 1, 1, true), // S
          new Key(7, "D", 240, 72, 1, 1, true), // D

          new Key(20, "Q", 240, 72, 1, 1, false), // Q

          new Key(225, "ðŸ¡…", 0, 0, 1.6, 1, true), // Left Shift
          new Key(224, "Ctrl", 0, 72, 1.2, 1, true), // Left Ctrl
          new Key(44, "__", 324, 72, 1.8, 1, true), // Space
        ];
      }
    }
    var keySize = parseInt(getComputedStyle(document.body).getPropertyValue('--key-size'));
    // saves the state of all keys in local storage
    function saveState(){
      // store key array, key elements, and key size information
      var storedKeys = [];
      var childKeys = document.getElementById('keyboard').getElementsByClassName('key');
      
      // turn key elements into arrays for storage
      for( i=0; i< childKeys.length; i++ )
      {
        var id = childKeys[i].getElementsByClassName('progress')[0].id;
        var label = childKeys[i].getElementsByClassName('label')[0].textContent;
        let keyData = [
        parseInt(id), label, parseInt(childKeys[i].style.left), parseInt(childKeys[i].style.top),
          childKeys[i].clientWidth/keySize, childKeys[i].clientHeight/keySize, childKeys[i].style.display == "none" ? false : true
        ]
        storedKeys.push(keyData);
        
      }
      // store updated keys in local storage
      localStorage.setItem("keys", JSON.stringify(storedKeys));
      
    }

    // create keys on screen
    var keyboard = document.getElementById("keyboard");
    for (var i = 0; i < keys.length; i++) {
      buildKey(keys[i]);
    } 


    // makes keys draggable
    var allkeys = document.getElementsByClassName("key");
    for (var i = 0; i < allkeys.length; i++) {
      dragElement(allkeys[i]);
    } 
                       
    function dragElement(elmnt) {
        // current position
        var x = parseInt(elmnt.style.left); 
        var y = parseInt(elmnt.style.top);

        // curent size
        var width = elmnt.clientWidth;
        var height = elmnt.clientHeight;

        // previous mouse position
        var oldPosX = 0;
        var oldPosY = 0;

        elmnt.onmousedown = dragMouseDown;
      

      function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        // get the mouse cursor position at startup:
       
        oldPosX = e.clientX;
        oldPosY = e.clientY;
        document.onmouseup = closeDragElement;
        // call a function whenever the cursor moves:
       
        if((e.clientX > parseInt(elmnt.style.left) + elmnt.offsetWidth)){
          oldPosX = e.clientX;
          document.onmousemove = elementResizeWidth;

          console.clear();

        } else if(e.clientY > parseInt(elmnt.style.top) + elmnt.offsetHeight){
          document.onmousemove = elementResizeHeight;
        }else{
          document.onmousemove = elementDrag;
        }
        

      }

      function elementResizeWidth(e){
        e = e || window.event;
        e.preventDefault();

        // calculate the new cursor position to add to width
        width += (e.clientX - oldPosX);
        
        // set the element's new position:
        elmnt.style.width = snapGrid(width) + "px";
        // set old values
        oldPosX = e.clientX;
      }

      function elementResizeHeight(e){
        e = e || window.event;
        e.preventDefault();

        // calculate the new cursor position to add to height
        height += (e.clientY - oldPosY);
        
        // set the element's new position:
        elmnt.style.height = snapGrid(height) + "px";
        // set old values
        oldPosY = e.clientY;
      }

      function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        // calculate the new cursor position:
        x += (e.clientX - oldPosX);
        y += (e.clientY - oldPosY);
        // set the element's new position:
        elmnt.style.top = snapGrid(y) + "px";
        elmnt.style.left = snapGrid(x) + "px";
        // set old values
        oldPosX = e.clientX;
        oldPosY = e.clientY;

      }

      function closeDragElement() {
        // stop moving when mouse button is released:
        document.onmouseup = null;
        document.onmousemove = null;
        saveState();
      }

      function snapGrid(num) {
         return Math.ceil(num / 12) * 12;
      }
    }
  </script>

</html>
